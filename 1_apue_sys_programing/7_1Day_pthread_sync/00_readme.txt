=========================================================
1_pthrd_mutex.c
    主线程和子线程互斥访问stdout打印各自内容


=========================================================
2_rwlock.c
    读写锁的案例：
        读共享，写独占，写锁优先级高

=========================================================
3_conditionVar_product_consumer.c
	//1.阻塞等待条件变量cond满足
	//2.释放已经掌握的互斥锁(解锁互斥变量)  unlock
	//3.当被唤醒，该函数返回时，解除阻塞且重新申请获取互斥锁 lock
    pthread_cond_wait(&has_product, &mutex);

    生产者和消费者模型
    
    bug修复：生产和消费的过程都上锁，避免出现内存泄露导致的段错误
    
=========================================================
4_sem_product_consumer.c
    使用信号量(进化版的互斥锁)设计的生产者和消费者模型
        只有5个空格
    

5_sem_product_consumer2.c
    在4的基础上，增加一个消费者

6_sem_timeout.c
    结合4的模型，+ sem_timedwait    
            
    一个线程读用户输入， 另一个线程打印“hello world”。
    如果用户无输入，则每隔5秒向屏幕打印一个“hello world”；
    如果用户有输入，立刻打印“hello world”到屏幕。												    
    
=========================================================
7_process_mutex.c
    使用互斥锁完成进程间同步
    struct mt {
        int num;
        pthread_mutex_t mutex;
        pthread_mutexattr_t mutexattr;
    };

    1.先修改锁的属性    pthread_mutexattr_t

    //之前传NULL表示线程间共享
    //通过修改这个参数可以改为进程间共享
    2.初始化一把mutex琐 pthread_mutex_init(&mm->mutex, &mm->mutexattr); 


=========================================================

=========================================================


=========================================================


