1_pthrd_crt.c
    创建线程：pthread_creat(...)
    查看线程ID：pthread_self();
    线程ID和线程号是不一样的
    linux环境下，所有线程，无论是创建还是其他，都是
        成功return 0,
        失败return 错误号：可以使用strerror(ret);转换为char *进行打印
        
============================================================
2_more_pthrd.c
    创建多个线程，利用i
         
============================================================
3_glb_var_pthrd.c
    查看子线程是否修改全局变量var

============================================================
4_1_pthrd_crt.c
    利用线程退出函数pthread_exit()对1_pthrd_crt.c进行修改
    
    return：返回到调用者那里去。
	pthread_exit()：将调用该函数的线程			
	exit: 将进程退出。
============================================================
5_1 pthrd_exit_join.c
	/*调用pthread_join可以获取线程的退出状态*/
	pthread_join(tid, (void **)&retval);      //wait(&status);
	printf("a = %d, b = %d \n", retval->a, retval->b);

    使用pthread_join获取进程退出状态，线程处理函数不传入参数    
        
5_2 pthrd_create_join_exit.c
    使用pthread_join获取进程退出状态，线程处理函数传入参数

5_3pthrd_loop_join.c
    创建多个进程，调动多个pthread_join可以获取线程的退出状态
    
============================================================
6_pthrd_detach.c
    方式0：利用pthread_detach函数分离主线程和子线程
    方式1：通过线程属性来分离主线程和子线程
    
============================================================
7_pthrd_endof3.c
    //方式1：printf 和 sleep向下都有系统调用，可以当做取消点(可以存档)
    //printf("thread 3: I'm going to die in 3 seconds ...\n");
    //sleep(1);

    //方式2：也可以自己添加的取消点
    pthread_testcancel();	

    pthread_cancel(tid);//调用cacel杀死一个线程后join阻塞的返回值是-1
	pthread_join(tid, &tret);


============================================================
8_pthrd_attr_detach.c
    通过线程属性来分离主线程和子线程

============================================================
9_max_pthrd.c
    测试一个线程可以创建多少线程

============================================================


============================================================


============================================================



============================================================








